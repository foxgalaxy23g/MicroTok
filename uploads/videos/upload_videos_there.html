<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>SECRET GAME</title>
  <style>
    /* Сброс отступов и прокрутки */
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }
    /* Канвас по центру страницы */
    canvas {
      display: block;
      margin: 0 auto;
      background: #000;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    // Получаем ссылку на canvas и его контекст
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Размеры и положение платформы
    let paddleWidth = 100;
    let paddleHeight = 20;
    let paddleX = (canvas.width - paddleWidth) / 2;
    const paddleY = canvas.height - paddleHeight - 10;
    const paddleSpeed = 7;

    // Флаги управления платформой
    let rightPressed = false;
    let leftPressed = false;

    // Объекты-мячи (поддержка нескольких мячей)
    const ballRadius = 10;
    const balls = [];

    // Функция создания мяча
    function createBall(x, y, dx, dy) {
      return { x, y, dx, dy, radius: ballRadius, color: "#fff" };
    }
    // Добавляем начальный мяч
    balls.push(createBall(canvas.width / 2, canvas.height - paddleHeight - 10 - ballRadius, 4, -4));

    // Настройки кирпичей
    const brickRowCount = 5;
    const brickColumnCount = 9;
    const brickWidth = 75;
    const brickHeight = 20;
    const brickPadding = 10;
    const brickOffsetTop = 30;
    const brickOffsetLeft = 30;
    let bricks = [];

    // Функция инициализации кирпичей (вызывается при старте и после уничтожения всех кирпичей)
    function initBricks() {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 }; // status: 1 – кирпич жив, 0 – уничтожен
        }
      }
    }
    initBricks();

    // Бонусы – падающие объекты
    const bonuses = [];
    const bonusWidth = 20;
    const bonusHeight = 20;
    const bonusFallSpeed = 2;
    // Функция создания бонуса. Тип bonusType может быть "life" (жизнь) или "ball" (дополнительный мяч)
    function createBonus(x, y, bonusType) {
      return { x, y, type: bonusType, width: bonusWidth, height: bonusHeight };
    }

    // Глобальные игровые переменные
    let lives = 3;
    let score = 0;

    // Обработчики событий клавиатуры и мыши
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);
    document.addEventListener("mousemove", mouseMoveHandler, false);

    function keyDownHandler(e) {
      if (e.key === "Right" || e.key === "ArrowRight") {
        rightPressed = true;
      } else if (e.key === "Left" || e.key === "ArrowLeft") {
        leftPressed = true;
      }
    }
    function keyUpHandler(e) {
      if (e.key === "Right" || e.key === "ArrowRight") {
        rightPressed = false;
      } else if (e.key === "Left" || e.key === "ArrowLeft") {
        leftPressed = false;
      }
    }
    function mouseMoveHandler(e) {
      const relativeX = e.clientX - canvas.offsetLeft;
      if (relativeX > 0 && relativeX < canvas.width) {
        paddleX = relativeX - paddleWidth / 2;
      }
    }

    // Функция отрисовки платформы
    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, paddleY, paddleWidth, paddleHeight);
      ctx.fillStyle = "#0095DD";
      ctx.fill();
      ctx.closePath();
    }

    // Функция отрисовки мячей
    function drawBalls() {
      balls.forEach(ball => {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.closePath();
      });
    }

    // Функция отрисовки кирпичей
    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    // Функция отрисовки бонусов
    function drawBonuses() {
      bonuses.forEach(bonus => {
        ctx.beginPath();
        if (bonus.type === "life") {
          ctx.fillStyle = "green";
        } else if (bonus.type === "ball") {
          ctx.fillStyle = "red";
        }
        ctx.rect(bonus.x, bonus.y, bonus.width, bonus.height);
        ctx.fill();
        ctx.closePath();
      });
    }

    // Отрисовка счета и количества жизней
    function drawScore() {
      ctx.font = "16px Arial";
      ctx.fillStyle = "#fff";
      ctx.fillText("Score: " + score, 8, 20);
    }
    function drawLives() {
      ctx.font = "16px Arial";
      ctx.fillStyle = "#fff";
      ctx.fillText("Lives: " + lives, canvas.width - 80, 20);
    }

    // Обработка столкновений мяча с кирпичами
    function collisionDetection() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const brick = bricks[c][r];
          if (brick.status === 1) {
            // Проверяем столкновение для каждого мяча
            balls.forEach(ball => {
              if (
                ball.x > brick.x &&
                ball.x < brick.x + brickWidth &&
                ball.y > brick.y &&
                ball.y < brick.y + brickHeight
              ) {
                ball.dy = -ball.dy;
                brick.status = 0;
                score++;
                // С шансом 10% бонус на жизнь, ещё 10% – бонус на дополнительный мяч
                const rand = Math.random();
                if (rand < 0.1) {
                  bonuses.push(createBonus(brick.x + brickWidth / 2 - bonusWidth / 2, brick.y + brickHeight / 2 - bonusHeight / 2, "life"));
                } else if (rand < 0.2) {
                  bonuses.push(createBonus(brick.x + brickWidth / 2 - bonusWidth / 2, brick.y + brickHeight / 2 - bonusHeight / 2, "ball"));
                }
              }
            });
          }
        }
      }
    }

    // Обновление позиции бонусов
    function updateBonuses() {
      for (let i = 0; i < bonuses.length; i++) {
        bonuses[i].y += bonusFallSpeed;
        // Если бонус пойман платформой
        if (
          bonuses[i].y + bonuses[i].height > paddleY &&
          bonuses[i].x + bonuses[i].width > paddleX &&
          bonuses[i].x < paddleX + paddleWidth &&
          bonuses[i].y < paddleY + paddleHeight
        ) {
          if (bonuses[i].type === "life") {
            lives++;
          } else if (bonuses[i].type === "ball") {
            // Новый мяч появляется у центра платформы
            balls.push(createBall(paddleX + paddleWidth / 2, paddleY - ballRadius, 4, -4));
          }
          bonuses.splice(i, 1);
          i--;
        } else if (bonuses[i].y > canvas.height) {
          // Удаляем бонус, если он вышел за пределы экрана
          bonuses.splice(i, 1);
          i--;
        }
      }
    }

    // Обновление движения мячей и обработка столкновений со стенами и платформой
    function updateBalls() {
      for (let i = 0; i < balls.length; i++) {
        const ball = balls[i];
        ball.x += ball.dx;
        ball.y += ball.dy;

        // Отскок от боковых стен
        if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
          ball.dx = -ball.dx;
        }
        // Отскок от верхней стены
        if (ball.y + ball.dy < ball.radius) {
          ball.dy = -ball.dy;
        }
        // Столкновение с нижней границей
        else if (ball.y + ball.dy > canvas.height - ball.radius) {
          // Если мяч попал по платформе – отражаем его
          if (ball.x > paddleX && ball.x < paddleX + paddleWidth && ball.y + ball.radius > paddleY) {
            ball.dy = -ball.dy;
          } else {
            // Удаляем мяч, если он пролетел мимо платформы
            balls.splice(i, 1);
            i--;
          }
        }
      }
    }

    // Если все кирпичи уничтожены, восстанавливаем их
    function checkBricksReset() {
      let allDestroyed = true;
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            allDestroyed = false;
            break;
          }
        }
        if (!allDestroyed) break;
      }
      if (allDestroyed) {
        initBricks();
      }
    }

    // Обновление позиции платформы
    function updatePaddle() {
      if (rightPressed && paddleX < canvas.width - paddleWidth) {
        paddleX += paddleSpeed;
      } else if (leftPressed && paddleX > 0) {
        paddleX -= paddleSpeed;
      }
    }

    // Основной цикл отрисовки и обновления игры
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawBricks();
      drawPaddle();
      drawBalls();
      drawBonuses();
      drawScore();
      drawLives();

      collisionDetection();
      updateBalls();
      updateBonuses();
      updatePaddle();
      checkBricksReset();

      // Если все мячи пропали – теряем жизнь
      if (balls.length === 0) {
        lives--;
        if (lives <= 0) {
          alert("GAME OVER");
          document.location.reload();
          return;
        } else {
          // Перезапускаем с одним мячом и центрируем платформу
          balls.push(createBall(canvas.width / 2, canvas.height - paddleHeight - 10 - ballRadius, 4, -4));
          paddleX = (canvas.width - paddleWidth) / 2;
        }
      }
      requestAnimationFrame(draw);
    }

    // Запуск игрового цикла
    draw();
  </script>
</body>
</html>
